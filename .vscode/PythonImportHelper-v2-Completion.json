[
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "_callback",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "_handle_error",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "importPath": "brainaccess.utils.exceptions",
        "description": "brainaccess.utils.exceptions",
        "isExtraImport": true,
        "detail": "brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "_dll",
        "importPath": "brainaccess.connect",
        "description": "brainaccess.connect",
        "isExtraImport": true,
        "detail": "brainaccess.connect",
        "documentation": {}
    },
    {
        "label": "processor",
        "importPath": "brainaccess.connect",
        "description": "brainaccess.connect",
        "isExtraImport": true,
        "detail": "brainaccess.connect",
        "documentation": {}
    },
    {
        "label": "brainaccess.core",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "brainaccess.core",
        "description": "brainaccess.core",
        "detail": "brainaccess.core",
        "documentation": {}
    },
    {
        "label": "_dll",
        "importPath": "brainaccess.core",
        "description": "brainaccess.core",
        "isExtraImport": true,
        "detail": "brainaccess.core",
        "documentation": {}
    },
    {
        "label": "_dll",
        "importPath": "brainaccess.core",
        "description": "brainaccess.core",
        "isExtraImport": true,
        "detail": "brainaccess.core",
        "documentation": {}
    },
    {
        "label": "_dll",
        "importPath": "brainaccess.core",
        "description": "brainaccess.core",
        "isExtraImport": true,
        "detail": "brainaccess.core",
        "documentation": {}
    },
    {
        "label": "_dll",
        "importPath": "brainaccess.core",
        "description": "brainaccess.core",
        "isExtraImport": true,
        "detail": "brainaccess.core",
        "documentation": {}
    },
    {
        "label": "DeviceInfo",
        "importPath": "brainaccess.core.device_info",
        "description": "brainaccess.core.device_info",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_info",
        "documentation": {}
    },
    {
        "label": "DeviceInfo",
        "importPath": "brainaccess.core.device_info",
        "description": "brainaccess.core.device_info",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_info",
        "documentation": {}
    },
    {
        "label": "Version",
        "importPath": "brainaccess.core.version",
        "description": "brainaccess.core.version",
        "isExtraImport": true,
        "detail": "brainaccess.core.version",
        "documentation": {}
    },
    {
        "label": "DeviceModel",
        "importPath": "brainaccess.core.device_model",
        "description": "brainaccess.core.device_model",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_model",
        "documentation": {}
    },
    {
        "label": "DeviceModel",
        "importPath": "brainaccess.core.device_model",
        "description": "brainaccess.core.device_model",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_model",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "unique",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "multimethod",
        "importPath": "multimethod",
        "description": "multimethod",
        "isExtraImport": true,
        "detail": "multimethod",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "BatteryInfo",
        "importPath": "brainaccess.core.battery_info",
        "description": "brainaccess.core.battery_info",
        "isExtraImport": true,
        "detail": "brainaccess.core.battery_info",
        "documentation": {}
    },
    {
        "label": "GainMode",
        "importPath": "brainaccess.core.gain_mode",
        "description": "brainaccess.core.gain_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "GainMode",
        "importPath": "brainaccess.core.gain_mode",
        "description": "brainaccess.core.gain_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "multiplier_to_gain_mode",
        "importPath": "brainaccess.core.gain_mode",
        "description": "brainaccess.core.gain_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "GainMode",
        "importPath": "brainaccess.core.gain_mode",
        "description": "brainaccess.core.gain_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "StreamRate",
        "importPath": "brainaccess.core.stream_rate",
        "description": "brainaccess.core.stream_rate",
        "isExtraImport": true,
        "detail": "brainaccess.core.stream_rate",
        "documentation": {}
    },
    {
        "label": "Annotation",
        "importPath": "brainaccess.core.annotation",
        "description": "brainaccess.core.annotation",
        "isExtraImport": true,
        "detail": "brainaccess.core.annotation",
        "documentation": {}
    },
    {
        "label": "Polarity",
        "importPath": "brainaccess.core.polarity",
        "description": "brainaccess.core.polarity",
        "isExtraImport": true,
        "detail": "brainaccess.core.polarity",
        "documentation": {}
    },
    {
        "label": "ImpedanceMeasurementMode",
        "importPath": "brainaccess.core.impedance_measurement_mode",
        "description": "brainaccess.core.impedance_measurement_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.impedance_measurement_mode",
        "documentation": {}
    },
    {
        "label": "ImpedanceMeasurementMode",
        "importPath": "brainaccess.core.impedance_measurement_mode",
        "description": "brainaccess.core.impedance_measurement_mode",
        "isExtraImport": true,
        "detail": "brainaccess.core.impedance_measurement_mode",
        "documentation": {}
    },
    {
        "label": "DeviceFeatures",
        "importPath": "brainaccess.core.device_features",
        "description": "brainaccess.core.device_features",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "DeviceFeatures",
        "importPath": "brainaccess.core.device_features",
        "description": "brainaccess.core.device_features",
        "isExtraImport": true,
        "detail": "brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "mne",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mne",
        "description": "mne",
        "detail": "mne",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "brainaccess.core.eeg_channel",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "brainaccess.core.eeg_channel",
        "description": "brainaccess.core.eeg_channel",
        "detail": "brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "importPath": "brainaccess.core.eeg_manager",
        "description": "brainaccess.core.eeg_manager",
        "isExtraImport": true,
        "detail": "brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "find_library",
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "isExtraImport": true,
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "getcwd",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "which",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "BuildHookInterface",
        "importPath": "hatchling.builders.hooks.plugin.interface",
        "description": "hatchling.builders.hooks.plugin.interface",
        "isExtraImport": true,
        "detail": "hatchling.builders.hooks.plugin.interface",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "acquisition",
        "importPath": "brainaccess.utils",
        "description": "brainaccess.utils",
        "isExtraImport": true,
        "detail": "brainaccess.utils",
        "documentation": {}
    },
    {
        "label": "acquisition",
        "importPath": "brainaccess.utils",
        "description": "brainaccess.utils",
        "isExtraImport": true,
        "detail": "brainaccess.utils",
        "documentation": {}
    },
    {
        "label": "acquisition",
        "importPath": "brainaccess.utils",
        "description": "brainaccess.utils",
        "isExtraImport": true,
        "detail": "brainaccess.utils",
        "documentation": {}
    },
    {
        "label": "acquisition",
        "importPath": "brainaccess.utils",
        "description": "brainaccess.utils",
        "isExtraImport": true,
        "detail": "brainaccess.utils",
        "documentation": {}
    },
    {
        "label": "butter",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "sosfiltfilt",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "brainaccess",
        "description": "brainaccess",
        "isExtraImport": true,
        "detail": "brainaccess",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "brainaccess",
        "description": "brainaccess",
        "isExtraImport": true,
        "detail": "brainaccess",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "gemini",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gemini",
        "description": "gemini",
        "detail": "gemini",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "WebSocket",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "WebSocketDisconnect",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "db_requests",
        "description": "db_requests",
        "isExtraImport": true,
        "detail": "db_requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "JSON",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "async_sessionmaker",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "as_declarative",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Mapped",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "mapped_column",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "get_signal_quality",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def get_signal_quality(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate signal quality for each channel in the data\n    This function estimates the EEG signal quality for each\n    channel based on amplitude variation and 50/60Hz noise level.\n    The supplied data should be unprocessed of 2-3 seconds length.\n    If signals do not pass the quality measures of this function,\n    then it means that they are really corrupted or the electrodes\n    are not fitted. Eye or muscle artifacts are not evaluated by\n    this function, signals containing theses should still pass the\n    quality measures.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "detrend",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def detrend(x: np.ndarray) -> np.ndarray:\n    \"\"\"Remove linear trend from each channel\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    -----------\n    np.ndarray\n        data array, shape (channels, time)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "mad",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def mad(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate median absolute deviation for each channel in the data\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    --------\n    np.ndarray\n    \"\"\"",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "get_minmax",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def get_minmax(x: np.ndarray) -> dict[str, np.ndarray]:\n    \"\"\"Calculate min and max for each channel in the data\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    --------\n    dict\n        min and max for each channel in the same order as x",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "median",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def median(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate median for each channel in the data\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    --------\n    np.ndarray\n        medians for each channel in the same order as x",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def mean(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate mean for each channel in the data\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    --------\n    np.ndarray\n        means for each channel in the same order as x",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "std",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def std(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate standard deviation for each channel in the data\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    --------\n    np.ndarray\n        standard deviation for each channel in the same order as x",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "demean",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def demean(x: np.ndarray) -> np.ndarray:\n    \"\"\"Subtract mean from each channel\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    -----------\n    np.ndarray\n        data array, shape (channels, time)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "standardize",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def standardize(x: np.ndarray) -> np.ndarray:\n    \"\"\"Data standardization\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    Returns\n    -----------\n    np.ndarray\n        data array, shape (channels, time)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "ewma",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def ewma(x: np.ndarray, alpha: float = 0.001) -> np.ndarray:\n    \"\"\"Exponential weighed moving average helper_function\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    alpha: float\n        new factor\n    Returns\n    -----------",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "ewma_standardize",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def ewma_standardize(\n    x: np.ndarray, alpha: float = 0.001, epsilon: float = 1e-4\n) -> np.ndarray:\n    \"\"\"Exponential weighed moving average standardization\n    First-order infinite impulse response filter that applies weighting factors which decrease exponentially\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    alpha: float",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "filter_notch",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def filter_notch(\n    x: np.ndarray, sampling_freq: float, center_freq: float, width_freq: float\n) -> np.ndarray:\n    \"\"\"Notch filter at desired frequency\n    Butterworth 4th order zero phase bandpass filter\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    sampling_freq: float",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "filter_bandpass",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def filter_bandpass(\n    x: np.ndarray, sampling_freq: float, freq_low: float, freq_high: float\n) -> np.ndarray:\n    \"\"\"Bandpass filter\n    Butterworth 5th order zero phase bandpass filter\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    sampling_freq: float",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "filter_highpass",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def filter_highpass(x: np.ndarray, sampling_freq: float, freq: float) -> np.ndarray:\n    \"\"\"High-pass filter\n    Butterworth 5th order zero phase high-pass filter\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    sampling_freq: float\n        data sampling rate\n    freq: float",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "filter_lowpass",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def filter_lowpass(x: np.ndarray, sampling_freq: float, freq: float) -> np.ndarray:\n    \"\"\"Low-pass filter\n    Butterworth 5th order zero phase low-pass filter\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    sampling_freq: float\n        data sampling rate\n    freq: float",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "fft",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def fft(x: np.ndarray, sampling_freq: float) -> dict:\n    \"\"\"Compute the discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm\n    Parameters\n    -----------\n    x: np.ndarray\n        data array, shape (channels, time)\n    sampling_freq: float\n        data sampling rate\n    Returns\n    -----------",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "cut_into_epochs",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def cut_into_epochs(\n    data: np.ndarray,\n    sfreq: float,\n    epoch_length: Optional[float] = None,\n    overlap: float = 0.5,\n) -> np.ndarray:\n    \"\"\"Cut data into epochs\n    Args:\n      data: np.ndarray: (n_channels, n_times)\n      sfreq: float:",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "get_bands",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def get_bands(\n    data: np.ndarray,\n    sfreq: float,\n    epoch_length: Optional[float] = None,\n    overlap: float = 0.1,\n    normalize: bool = False,\n):\n    \"\"\"EEG power in delta, theta, alpha, beta and gamma frequency bands for each channel\n    Args:\n      data: np.ndarray: (n_channels, n_times)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "get_pow_freq_bands",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "def get_pow_freq_bands(\n    data: np.ndarray,\n    sfreq: float,\n    freq_bands: np.ndarray = np.array([0.5, 4.0, 8.0, 13.0, 30.0, 100.0]),\n    normalize: bool = False,\n) -> np.ndarray:\n    \"\"\"Power Spectrum (computed by frequency bands).\n    Args:\n      data: np.ndarray: (n_channels, n_times)\n      sfreq: float:",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_get_signal_quality.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_get_signal_quality.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_get_signal_quality.restype = None\n_dll.ba_bci_connect_detrend.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_get_signal_quality.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_get_signal_quality.restype = None\n_dll.ba_bci_connect_detrend.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_detrend.restype = None\n_dll.ba_bci_connect_median.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_detrend.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_detrend.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_detrend.restype = None\n_dll.ba_bci_connect_median.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_detrend.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_detrend.restype = None\n_dll.ba_bci_connect_median.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_median.restype = None\n_dll.ba_bci_connect_mad.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_median.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_median.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_median.restype = None\n_dll.ba_bci_connect_mad.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_median.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_median.restype = None\n_dll.ba_bci_connect_mad.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_mad.restype = None\n_dll.ba_bci_connect_mean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_mad.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_mad.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_mad.restype = None\n_dll.ba_bci_connect_mean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_mad.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_mad.restype = None\n_dll.ba_bci_connect_mean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_mean.restype = None\n_dll.ba_bci_connect_std.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_mean.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_mean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_mean.restype = None\n_dll.ba_bci_connect_std.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_mean.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_mean.restype = None\n_dll.ba_bci_connect_std.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_std.restype = None\n_dll.ba_bci_connect_demean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_std.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_std.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_std.restype = None\n_dll.ba_bci_connect_demean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_std.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_std.restype = None\n_dll.ba_bci_connect_demean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_demean.restype = None\n_dll.ba_bci_connect_standartize.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_demean.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_demean.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_demean.restype = None\n_dll.ba_bci_connect_standartize.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_demean.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_demean.restype = None\n_dll.ba_bci_connect_standartize.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_standartize.restype = None\n_dll.ba_bci_connect_ewma.argtypes = (\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_standartize.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_standartize.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_standartize.restype = None\n_dll.ba_bci_connect_ewma.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_standartize.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_standartize.restype = None\n_dll.ba_bci_connect_ewma.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n)\n_dll.ba_bci_connect_ewma.restype = None\n_dll.ba_bci_connect_ewma_standartize.argtypes = (",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_ewma.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_ewma.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n)\n_dll.ba_bci_connect_ewma.restype = None\n_dll.ba_bci_connect_ewma_standartize.argtypes = (\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_ewma.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_ewma.restype = None\n_dll.ba_bci_connect_ewma_standartize.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n)\n_dll.ba_bci_connect_ewma_standartize.restype = None",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_ewma_standartize.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_ewma_standartize.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n)\n_dll.ba_bci_connect_ewma_standartize.restype = None\n_dll.ba_bci_connect_filter_notch.argtypes = (",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_ewma_standartize.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_ewma_standartize.restype = None\n_dll.ba_bci_connect_filter_notch.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_notch.restype = None",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_notch.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_notch.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_notch.restype = None\n_dll.ba_bci_connect_filter_bandpass.argtypes = (",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_notch.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_notch.restype = None\n_dll.ba_bci_connect_filter_bandpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_bandpass.restype = None",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_bandpass.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_bandpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_bandpass.restype = None\n_dll.ba_bci_connect_filter_highpass.argtypes = (",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_bandpass.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_bandpass.restype = None\n_dll.ba_bci_connect_filter_highpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_highpass.restype = None\n_dll.ba_bci_connect_filter_lowpass.argtypes = (",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_highpass.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_highpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_highpass.restype = None\n_dll.ba_bci_connect_filter_lowpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_highpass.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_highpass.restype = None\n_dll.ba_bci_connect_filter_lowpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_lowpass.restype = None\n_dll.ba_bci_connect_fft.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_lowpass.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_lowpass.argtypes = (\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.c_double,\n)\n_dll.ba_bci_connect_filter_lowpass.restype = None\n_dll.ba_bci_connect_fft.argtypes = [\n    ctypes.POINTER(ctypes.c_double),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_filter_lowpass.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_filter_lowpass.restype = None\n_dll.ba_bci_connect_fft.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_fft.restype = None",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_fft.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_fft.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.c_double,\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_fft.restype = None\n_dll.ba_bci_connect_minmax.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_fft.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_fft.restype = None\n_dll.ba_bci_connect_minmax.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_minmax.restype = None\ndef get_signal_quality(x: np.ndarray) -> np.ndarray:",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_minmax.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_minmax.argtypes = [\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.c_size_t,\n    ctypes.c_size_t,\n    ctypes.POINTER(ctypes.c_double),\n    ctypes.POINTER(ctypes.c_double),\n]\n_dll.ba_bci_connect_minmax.restype = None\ndef get_signal_quality(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate signal quality for each channel in the data",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "_dll.ba_bci_connect_minmax.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "peekOfCode": "_dll.ba_bci_connect_minmax.restype = None\ndef get_signal_quality(x: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate signal quality for each channel in the data\n    This function estimates the EEG signal quality for each\n    channel based on amplitude variation and 50/60Hz noise level.\n    The supplied data should be unprocessed of 2-3 seconds length.\n    If signals do not pass the quality measures of this function,\n    then it means that they are really corrupted or the electrodes\n    are not fitted. Eye or muscle artifacts are not evaluated by\n    this function, signals containing theses should still pass the",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.connect.processor",
        "documentation": {}
    },
    {
        "label": "Annotation",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.annotation",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.annotation",
        "peekOfCode": "class Annotation(ctypes.Structure):\n    \"\"\"Represents a single annotation with a timestamp and text.\n    This class is used to mark specific points in time with a descriptive\n    label, which is useful for synchronizing EEG data with external events.\n    Attributes\n    ----------\n    timestamp : int\n        The sample number corresponding to the time the annotation was recorded.\n        This allows for precise alignment with the EEG data stream.\n    annotation : str",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.annotation",
        "documentation": {}
    },
    {
        "label": "BatteryInfo",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.battery_info",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.battery_info",
        "peekOfCode": "class BatteryInfo(ctypes.Structure):\n    \"\"\"Provides essential information about the device's battery status.\n    This class includes the current charge level, whether a charger is connected,\n    and if the battery is actively charging. This is useful for monitoring the\n    device's power state and ensuring it remains operational during data\n    acquisition.\n    Attributes\n    ----------\n    level : int\n        The battery charge percentage, ranging from 0 to 100.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.battery_info",
        "documentation": {}
    },
    {
        "label": "BaBleDevice",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.ble_device",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.ble_device",
        "peekOfCode": "class BaBleDevice(ctypes.Structure):\n    \"\"\"Represents a Bluetooth Low Energy (BLE) device found during a scan.\n    This class stores the device's name and MAC address, which are essential\n    for identifying and connecting to a specific BrainAccess device.\n    Attributes\n    ----------\n    name : str\n        The broadcasted name of the BLE device.\n    mac_address : str\n        The unique MAC address of the BLE device.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.ble_device",
        "documentation": {}
    },
    {
        "label": "ChargingSettings",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.charging_settings",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.charging_settings",
        "peekOfCode": "class ChargingSettings(ctypes.Structure):\n    _fields_ = [\n        (\"_sleep_timeout\", ctypes.c_int8),\n        (\"_enabled_on_while_charging\", ctypes.c_bool),\n    ]\n    @property\n    def sleep_timeout(self):\n        \"\"\"Sleep timeout in minutes.\n        If the device is not used for this time it will go to sleep.\"\"\"\n        return self._sleep_timeout",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.charging_settings",
        "documentation": {}
    },
    {
        "label": "DeviceFeatures",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "class DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes\n    and accelerometers, determine the electrode configuration, and get the total\n    number of electrodes available on the device.\n    Parameters\n    ----------\n    device_info : DeviceInfo\n        An object containing the device's information, used to identify the\n        specific model and its capabilities.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_has_gyro.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_has_gyro.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_has_gyro.restype = ctypes.c_bool\n# has_accel()\n_dll.ba_core_device_features_has_accel.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_has_accel.restype = ctypes.c_bool\n# is_bipolar()\n_dll.ba_core_device_features_is_bipolar.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_has_gyro.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_has_gyro.restype = ctypes.c_bool\n# has_accel()\n_dll.ba_core_device_features_has_accel.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_has_accel.restype = ctypes.c_bool\n# is_bipolar()\n_dll.ba_core_device_features_is_bipolar.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_has_accel.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_has_accel.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_has_accel.restype = ctypes.c_bool\n# is_bipolar()\n_dll.ba_core_device_features_is_bipolar.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_has_accel.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_has_accel.restype = ctypes.c_bool\n# is_bipolar()\n_dll.ba_core_device_features_is_bipolar.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_is_bipolar.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_is_bipolar.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_is_bipolar.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_is_bipolar.restype = ctypes.c_bool\n# electrode_count()\n_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_electrode_count.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_electrode_count.argtypes = [ctypes.c_void_p]\n_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes\n    and accelerometers, determine the electrode configuration, and get the total\n    number of electrodes available on the device.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_electrode_count.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_electrode_count.restype = ctypes.c_uint8\n# device_features_get()\n_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes\n    and accelerometers, determine the electrode configuration, and get the total\n    number of electrodes available on the device.\n    Parameters",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_get.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_get.argtypes = [ctypes.POINTER(DeviceInfo)]\n_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes\n    and accelerometers, determine the electrode configuration, and get the total\n    number of electrodes available on the device.\n    Parameters\n    ----------\n    device_info : DeviceInfo",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "_dll.ba_core_device_features_get.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "peekOfCode": "_dll.ba_core_device_features_get.restype = ctypes.c_void_p\nclass DeviceFeatures:\n    \"\"\"Provides an interface to query the supported features of a device.\n    This class allows you to check for the presence of sensors like gyroscopes\n    and accelerometers, determine the electrode configuration, and get the total\n    number of electrodes available on the device.\n    Parameters\n    ----------\n    device_info : DeviceInfo\n        An object containing the device's information, used to identify the",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_features",
        "documentation": {}
    },
    {
        "label": "DeviceInfo",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_info",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_info",
        "peekOfCode": "class DeviceInfo(ctypes.Structure):\n    \"\"\"Contains detailed information about a BrainAccess device.\n    This class holds static information about the device, such as its model,\n    hardware and firmware versions, and serial number. This is useful for\n    identifying the device and understanding its capabilities.\n    Attributes\n    ----------\n    device_model : DeviceModel\n        The model of the device.\n    hardware_version : Version",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_info",
        "documentation": {}
    },
    {
        "label": "DeviceModel",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_model",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_model",
        "peekOfCode": "class DeviceModel(enum.Enum):\n    \"\"\"Enumeration of the different BrainAccess device models.\n    This enum provides a clear and standardized way to identify the specific\n    model of a BrainAccess device.\n    Attributes\n    ----------\n    MINI : int\n        BrainAccess MINI\n    MIDI : int\n        BrainAccess MIDI (16 Channels)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.device_model",
        "documentation": {}
    },
    {
        "label": "SAMPLE_NUMBER",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "SAMPLE_NUMBER = 0\nELECTRODE_MEASUREMENT = 1\nELECTRODE_CONTACT_P = 513\nELECTRODE_CONTACT = 1025\nELECTRODE_CONTACT_N = 1537\nDIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "ELECTRODE_MEASUREMENT",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "ELECTRODE_MEASUREMENT = 1\nELECTRODE_CONTACT_P = 513\nELECTRODE_CONTACT = 1025\nELECTRODE_CONTACT_N = 1537\nDIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "ELECTRODE_CONTACT_P",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "ELECTRODE_CONTACT_P = 513\nELECTRODE_CONTACT = 1025\nELECTRODE_CONTACT_N = 1537\nDIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "ELECTRODE_CONTACT",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "ELECTRODE_CONTACT = 1025\nELECTRODE_CONTACT_N = 1537\nDIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "ELECTRODE_CONTACT_N",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "ELECTRODE_CONTACT_N = 1537\nDIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "DIGITAL_INPUT",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "DIGITAL_INPUT = 2049\nGYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "GYROSCOPE",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "GYROSCOPE = 2497\nACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "ACCELEROMETER",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "ACCELEROMETER = 2561\nSTREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "STREAMING",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "peekOfCode": "STREAMING = 2625",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_channel",
        "documentation": {}
    },
    {
        "label": "EEGManager",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "class EEGManager:\n    \"\"\"Manages all communication with a BrainAccess device.\n    The `EEGManager` is the primary interface for connecting to, configuring,\n    and streaming data from a BrainAccess device. It handles the low-level\n    details of Bluetooth communication and provides a high-level API for\n    controlling the device.\n    \"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initializes a new EEGManager instance.\n        Warning",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_new.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_new.argtypes = []\n_dll.ba_eeg_manager_new.restype = ctypes.c_void_p\n# destructor\n_dll.ba_eeg_manager_free.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_free.restype = None\n# connect(device_name)\n_dll.ba_eeg_manager_connect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_char_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_new.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_new.restype = ctypes.c_void_p\n# destructor\n_dll.ba_eeg_manager_free.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_free.restype = None\n# connect(device_name)\n_dll.ba_eeg_manager_connect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_char_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p),\n    ctypes.c_void_p,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_free.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_free.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_free.restype = None\n# connect(device_name)\n_dll.ba_eeg_manager_connect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_char_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_connect.restype = ctypes.c_uint8",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_free.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_free.restype = None\n# connect(device_name)\n_dll.ba_eeg_manager_connect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_char_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_connect.restype = ctypes.c_uint8\n# is_connected()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_connect.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_connect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_char_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_connect.restype = ctypes.c_uint8\n# is_connected()\n_dll.ba_eeg_manager_is_connected.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_connected.restype = ctypes.c_bool",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_connect.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_connect.restype = ctypes.c_uint8\n# is_connected()\n_dll.ba_eeg_manager_is_connected.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_connected.restype = ctypes.c_bool\n# disconnect()\n_dll.ba_eeg_manager_disconnect.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_disconnect.restype = None\n# start_stream()\n_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_is_connected.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_is_connected.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_connected.restype = ctypes.c_bool\n# disconnect()\n_dll.ba_eeg_manager_disconnect.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_disconnect.restype = None\n# start_stream()\n_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_is_connected.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_is_connected.restype = ctypes.c_bool\n# disconnect()\n_dll.ba_eeg_manager_disconnect.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_disconnect.restype = None\n# start_stream()\n_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_disconnect.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_disconnect.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_disconnect.restype = None\n# start_stream()\n_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_start_stream.restype = ctypes.c_uint8\n# stop_stream()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_disconnect.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_disconnect.restype = None\n# start_stream()\n_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_start_stream.restype = ctypes.c_uint8\n# stop_stream()\n_dll.ba_eeg_manager_stop_stream.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_start_stream.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_start_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_start_stream.restype = ctypes.c_uint8\n# stop_stream()\n_dll.ba_eeg_manager_stop_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_start_stream.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_start_stream.restype = ctypes.c_uint8\n# stop_stream()\n_dll.ba_eeg_manager_stop_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_stop_stream.restype = ctypes.c_uint8\n# is_streaming()\n_dll.ba_eeg_manager_is_streaming.argtypes = [ctypes.c_void_p]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_stop_stream.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_stop_stream.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_stop_stream.restype = ctypes.c_uint8\n# is_streaming()\n_dll.ba_eeg_manager_is_streaming.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_streaming.restype = ctypes.c_bool\n# load_config()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_stop_stream.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_stop_stream.restype = ctypes.c_uint8\n# is_streaming()\n_dll.ba_eeg_manager_is_streaming.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_streaming.restype = ctypes.c_bool\n# load_config()\n_dll.ba_eeg_manager_load_config.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_is_streaming.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_is_streaming.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_is_streaming.restype = ctypes.c_bool\n# load_config()\n_dll.ba_eeg_manager_load_config.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_load_config.restype = ctypes.c_uint8\n# get_battery_info()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_is_streaming.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_is_streaming.restype = ctypes.c_bool\n# load_config()\n_dll.ba_eeg_manager_load_config.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_load_config.restype = ctypes.c_uint8\n# get_battery_info()\n_dll.ba_eeg_manager_get_battery_info.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_load_config.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_load_config.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_load_config.restype = ctypes.c_uint8\n# get_battery_info()\n_dll.ba_eeg_manager_get_battery_info.argtypes = [\n    ctypes.c_void_p,\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_load_config.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_load_config.restype = ctypes.c_uint8\n# get_battery_info()\n_dll.ba_eeg_manager_get_battery_info.argtypes = [\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_get_battery_info.restype = BatteryInfo\n# set_channel_enabled()\n_dll.ba_eeg_manager_set_channel_enabled.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_battery_info.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_battery_info.argtypes = [\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_get_battery_info.restype = BatteryInfo\n# set_channel_enabled()\n_dll.ba_eeg_manager_set_channel_enabled.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_bool,\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_battery_info.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_battery_info.restype = BatteryInfo\n# set_channel_enabled()\n_dll.ba_eeg_manager_set_channel_enabled.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_bool,\n]\n_dll.ba_eeg_manager_set_channel_enabled.restype = None\n# set_channel_gain()\n_dll.ba_eeg_manager_set_channel_gain.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_enabled.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_enabled.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_bool,\n]\n_dll.ba_eeg_manager_set_channel_enabled.restype = None\n# set_channel_gain()\n_dll.ba_eeg_manager_set_channel_gain.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_enabled.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_enabled.restype = None\n# set_channel_gain()\n_dll.ba_eeg_manager_set_channel_gain.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_channel_gain.restype = None\n# set_channel_bias()\n_dll.ba_eeg_manager_set_channel_bias.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_gain.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_gain.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_channel_gain.restype = None\n# set_channel_bias()\n_dll.ba_eeg_manager_set_channel_bias.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_gain.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_gain.restype = None\n# set_channel_bias()\n_dll.ba_eeg_manager_set_channel_bias.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_channel_bias.restype = None\n# set_impedance_mode()\n_dll.ba_eeg_manager_set_impedance_mode.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_bias.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_bias.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint16,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_channel_bias.restype = None\n# set_impedance_mode()\n_dll.ba_eeg_manager_set_impedance_mode.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_channel_bias.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_channel_bias.restype = None\n# set_impedance_mode()\n_dll.ba_eeg_manager_set_impedance_mode.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_impedance_mode.restype = None\n# get_device_info()\n_dll.ba_eeg_manager_get_device_info.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_device_info.restype = ctypes.POINTER(DeviceInfo)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_impedance_mode.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_impedance_mode.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_impedance_mode.restype = None\n# get_device_info()\n_dll.ba_eeg_manager_get_device_info.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_device_info.restype = ctypes.POINTER(DeviceInfo)\n# get_channel_index()\n_dll.ba_eeg_manager_get_channel_index.argtypes = [ctypes.c_void_p, ctypes.c_uint16]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_impedance_mode.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_impedance_mode.restype = None\n# get_device_info()\n_dll.ba_eeg_manager_get_device_info.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_device_info.restype = ctypes.POINTER(DeviceInfo)\n# get_channel_index()\n_dll.ba_eeg_manager_get_channel_index.argtypes = [ctypes.c_void_p, ctypes.c_uint16]\n_dll.ba_eeg_manager_get_channel_index.restype = ctypes.c_size_t\n# get_sample_frequency()\n_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_device_info.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_device_info.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_device_info.restype = ctypes.POINTER(DeviceInfo)\n# get_channel_index()\n_dll.ba_eeg_manager_get_channel_index.argtypes = [ctypes.c_void_p, ctypes.c_uint16]\n_dll.ba_eeg_manager_get_channel_index.restype = ctypes.c_size_t\n# get_sample_frequency()\n_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_device_info.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_device_info.restype = ctypes.POINTER(DeviceInfo)\n# get_channel_index()\n_dll.ba_eeg_manager_get_channel_index.argtypes = [ctypes.c_void_p, ctypes.c_uint16]\n_dll.ba_eeg_manager_get_channel_index.restype = ctypes.c_size_t\n# get_sample_frequency()\n_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_channel_index.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_channel_index.argtypes = [ctypes.c_void_p, ctypes.c_uint16]\n_dll.ba_eeg_manager_get_channel_index.restype = ctypes.c_size_t\n# get_sample_frequency()\n_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(\n        None,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_channel_index.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_channel_index.restype = ctypes.c_size_t\n# get_sample_frequency()\n_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(\n        None,\n        ctypes.POINTER(ctypes.c_void_p),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_sample_frequency.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_sample_frequency.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(\n        None,\n        ctypes.POINTER(ctypes.c_void_p),\n        ctypes.c_size_t,\n        ctypes.c_void_p,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_sample_frequency.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_sample_frequency.restype = ctypes.c_uint16\n# set_callback_chunk()\n_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(\n        None,\n        ctypes.POINTER(ctypes.c_void_p),\n        ctypes.c_size_t,\n        ctypes.c_void_p,\n    ),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_chunk.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_chunk.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(\n        None,\n        ctypes.POINTER(ctypes.c_void_p),\n        ctypes.c_size_t,\n        ctypes.c_void_p,\n    ),\n    ctypes.c_void_p,\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_chunk.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_chunk.restype = None\n# set_callback_battery()\n_dll.ba_eeg_manager_set_callback_battery.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.POINTER(BatteryInfo), ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_set_callback_battery.restype = None\n# set_callback_disconnect()\n_dll.ba_eeg_manager_set_callback_disconnect.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_battery.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_battery.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.POINTER(BatteryInfo), ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_set_callback_battery.restype = None\n# set_callback_disconnect()\n_dll.ba_eeg_manager_set_callback_disconnect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_battery.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_battery.restype = None\n# set_callback_disconnect()\n_dll.ba_eeg_manager_set_callback_disconnect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_set_callback_disconnect.restype = None\n# update firmware\n_dll.ba_eeg_manager_start_update.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_disconnect.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_disconnect.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_set_callback_disconnect.restype = None\n# update firmware\n_dll.ba_eeg_manager_start_update.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t),",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_callback_disconnect.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_callback_disconnect.restype = None\n# update firmware\n_dll.ba_eeg_manager_start_update.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_start_update.restype = ctypes.c_uint8\n# annotate()\n_dll.ba_eeg_manager_annotate.argtypes = [ctypes.c_void_p, ctypes.c_char_p]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_start_update.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_start_update.argtypes = [\n    ctypes.c_void_p,\n    ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t),\n    ctypes.c_void_p,\n]\n_dll.ba_eeg_manager_start_update.restype = ctypes.c_uint8\n# annotate()\n_dll.ba_eeg_manager_annotate.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n_dll.ba_eeg_manager_annotate.restype = ctypes.c_uint8\n# get_annotations()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_start_update.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_start_update.restype = ctypes.c_uint8\n# annotate()\n_dll.ba_eeg_manager_annotate.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n_dll.ba_eeg_manager_annotate.restype = ctypes.c_uint8\n# get_annotations()\n_dll.ba_eeg_manager_get_annotations.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(Annotation)),\n    ctypes.POINTER(ctypes.c_size_t),\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_annotate.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_annotate.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n_dll.ba_eeg_manager_annotate.restype = ctypes.c_uint8\n# get_annotations()\n_dll.ba_eeg_manager_get_annotations.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(Annotation)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_annotations.restype = None\n# clear_annotations()",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_annotate.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_annotate.restype = ctypes.c_uint8\n# get_annotations()\n_dll.ba_eeg_manager_get_annotations.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(Annotation)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_annotations.restype = None\n# clear_annotations()\n_dll.ba_eeg_manager_clear_annotations.argtypes = [ctypes.c_void_p]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_annotations.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_annotations.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(Annotation)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_annotations.restype = None\n# clear_annotations()\n_dll.ba_eeg_manager_clear_annotations.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_clear_annotations.restype = None\n# Stream size type info super secret function thingy",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_annotations.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_annotations.restype = None\n# clear_annotations()\n_dll.ba_eeg_manager_clear_annotations.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_clear_annotations.restype = None\n# Stream size type info super secret function thingy\n_dll.ba_eeg_manager_get_stream_channel_data_types.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(ctypes.c_uint8)),\n    ctypes.POINTER(ctypes.c_size_t),\n]",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_clear_annotations.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_clear_annotations.argtypes = [ctypes.c_void_p]\n_dll.ba_eeg_manager_clear_annotations.restype = None\n# Stream size type info super secret function thingy\n_dll.ba_eeg_manager_get_stream_channel_data_types.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(ctypes.c_uint8)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_stream_channel_data_types.restype = None\n# Set sample rate",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_clear_annotations.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_clear_annotations.restype = None\n# Stream size type info super secret function thingy\n_dll.ba_eeg_manager_get_stream_channel_data_types.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(ctypes.c_uint8)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_stream_channel_data_types.restype = None\n# Set sample rate\n_dll.ba_eeg_manager_set_data_stream_rate.argtypes = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_stream_channel_data_types.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_stream_channel_data_types.argtypes = [\n    ctypes.c_void_p,\n    ctypes.POINTER(ctypes.POINTER(ctypes.c_uint8)),\n    ctypes.POINTER(ctypes.c_size_t),\n]\n_dll.ba_eeg_manager_get_stream_channel_data_types.restype = None\n# Set sample rate\n_dll.ba_eeg_manager_set_data_stream_rate.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_get_stream_channel_data_types.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_get_stream_channel_data_types.restype = None\n# Set sample rate\n_dll.ba_eeg_manager_set_data_stream_rate.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_data_stream_rate.restype = ctypes.c_uint8\n_managers_mtx = threading.Lock()\n_managers: dict = dict()\n_types_map = [",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_data_stream_rate.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_data_stream_rate.argtypes = [\n    ctypes.c_void_p,\n    ctypes.c_uint8,\n]\n_dll.ba_eeg_manager_set_data_stream_rate.restype = ctypes.c_uint8\n_managers_mtx = threading.Lock()\n_managers: dict = dict()\n_types_map = [\n    ctypes.c_float,  # 0\n    ctypes.c_uint8,  # 1",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_dll.ba_eeg_manager_set_data_stream_rate.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_dll.ba_eeg_manager_set_data_stream_rate.restype = ctypes.c_uint8\n_managers_mtx = threading.Lock()\n_managers: dict = dict()\n_types_map = [\n    ctypes.c_float,  # 0\n    ctypes.c_uint8,  # 1\n    ctypes.c_size_t,  # 2\n    ctypes.c_double,  # 3\n]\n@ctypes.CFUNCTYPE(None, ctypes.c_void_p)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_managers_mtx",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_managers_mtx = threading.Lock()\n_managers: dict = dict()\n_types_map = [\n    ctypes.c_float,  # 0\n    ctypes.c_uint8,  # 1\n    ctypes.c_size_t,  # 2\n    ctypes.c_double,  # 3\n]\n@ctypes.CFUNCTYPE(None, ctypes.c_void_p)\ndef _callback_stop_stream(data: ctypes.c_void_p) -> None:",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "_types_map",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "peekOfCode": "_types_map = [\n    ctypes.c_float,  # 0\n    ctypes.c_uint8,  # 1\n    ctypes.c_size_t,  # 2\n    ctypes.c_double,  # 3\n]\n@ctypes.CFUNCTYPE(None, ctypes.c_void_p)\ndef _callback_stop_stream(data: ctypes.c_void_p) -> None:\n    with _managers_mtx:\n        mgr = _managers.get(data)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.eeg_manager",
        "documentation": {}
    },
    {
        "label": "EBaChargeStates",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "peekOfCode": "class EBaChargeStates(Enum):\n    \"\"\"Enumeration of the possible battery charging states.\"\"\"\n    e_ba_charge_states_unknown = 0\n    e_ba_charge_states_charging = 1\n    e_ba_charge_states_discharging_active = 2\n    e_ba_charge_states_discharging_inactive = 3\n    e_ba_charge_states_last = 4\n@unique\nclass EBaChargeLevel(Enum):\n    \"\"\"Enumeration of the battery charge levels.\"\"\"",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "documentation": {}
    },
    {
        "label": "EBaChargeLevel",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "peekOfCode": "class EBaChargeLevel(Enum):\n    \"\"\"Enumeration of the battery charge levels.\"\"\"\n    e_ba_charge_level_unknown = 0\n    e_ba_charge_level_good = 1\n    e_ba_charge_level_low = 2\n    e_ba_charge_level_critical = 3\n    e_ba_charge_level_last = 4\nclass FullBatteryInfo(ctypes.Structure):\n    \"\"\"Provides comprehensive information about the device's battery.\n    This class extends the basic battery info with more detailed metrics such as",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "documentation": {}
    },
    {
        "label": "FullBatteryInfo",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "peekOfCode": "class FullBatteryInfo(ctypes.Structure):\n    \"\"\"Provides comprehensive information about the device's battery.\n    This class extends the basic battery info with more detailed metrics such as\n    health, voltage, and current, providing a complete picture of the battery's\n    status.\n    Attributes\n    ----------\n    is_charger_connected : bool\n        True if a charger is connected to the device.\n    level : int",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.full_battery_info",
        "documentation": {}
    },
    {
        "label": "GainMode",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "class GainMode(Enum):\n    \"\"\"Enumeration of the available gain modes for the device's amplifiers.\n    The gain mode determines the amplification factor applied to the analog\n    signal before it is digitized. Higher gain values are suitable for measuring\n    low-amplitude signals, while lower gain values are better for signals with\n    a larger dynamic range.\n    Attributes\n    ----------\n    X1 : int\n        1x gain.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "gain_mode_to_multiplier",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "def gain_mode_to_multiplier(gain_mode: GainMode) -> int:\n    \"\"\"Converts a `GainMode` enum member to its integer multiplier.\n    Parameters\n    ----------\n    gain_mode : GainMode\n        The gain mode to convert.\n    Returns\n    -------\n    int\n        The integer multiplier corresponding to the gain mode (e.g., `GainMode.X12` returns 12).",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "multiplier_to_gain_mode",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "def multiplier_to_gain_mode(multiplier: int) -> GainMode:\n    \"\"\"Converts an integer multiplier to its corresponding `GainMode` enum member.\n    Parameters\n    ----------\n    multiplier : int\n        The integer multiplier to convert.\n    Returns\n    -------\n    GainMode\n        The `GainMode` enum member corresponding to the multiplier.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "_dll.ba_gain_mode_to_multiplier.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "_dll.ba_gain_mode_to_multiplier.argtypes = [ctypes.c_uint8]\n_dll.ba_gain_mode_to_multiplier.restype = ctypes.c_int\ndef gain_mode_to_multiplier(gain_mode: GainMode) -> int:\n    \"\"\"Converts a `GainMode` enum member to its integer multiplier.\n    Parameters\n    ----------\n    gain_mode : GainMode\n        The gain mode to convert.\n    Returns\n    -------",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "_dll.ba_gain_mode_to_multiplier.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "_dll.ba_gain_mode_to_multiplier.restype = ctypes.c_int\ndef gain_mode_to_multiplier(gain_mode: GainMode) -> int:\n    \"\"\"Converts a `GainMode` enum member to its integer multiplier.\n    Parameters\n    ----------\n    gain_mode : GainMode\n        The gain mode to convert.\n    Returns\n    -------\n    int",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "_dll.ba_multiplier_to_gain_mode.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "_dll.ba_multiplier_to_gain_mode.argtypes = [ctypes.c_int]\n_dll.ba_multiplier_to_gain_mode.restype = ctypes.c_uint8\ndef multiplier_to_gain_mode(multiplier: int) -> GainMode:\n    \"\"\"Converts an integer multiplier to its corresponding `GainMode` enum member.\n    Parameters\n    ----------\n    multiplier : int\n        The integer multiplier to convert.\n    Returns\n    -------",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "_dll.ba_multiplier_to_gain_mode.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "peekOfCode": "_dll.ba_multiplier_to_gain_mode.restype = ctypes.c_uint8\ndef multiplier_to_gain_mode(multiplier: int) -> GainMode:\n    \"\"\"Converts an integer multiplier to its corresponding `GainMode` enum member.\n    Parameters\n    ----------\n    multiplier : int\n        The integer multiplier to convert.\n    Returns\n    -------\n    GainMode",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.gain_mode",
        "documentation": {}
    },
    {
        "label": "ImpedanceMeasurementMode",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.impedance_measurement_mode",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.impedance_measurement_mode",
        "peekOfCode": "class ImpedanceMeasurementMode(enum.Enum):\n    \"\"\"Enumeration of the available impedance measurement modes.\n    Impedance measurement is used to assess the quality of the electrode-skin\n    contact. Different modes use different frequencies for the measurement.\n    Attributes\n    ----------\n    OFF : int\n        Impedance measurement is disabled.\n    HZ_7_8 : int\n        Uses a 7.8 Hz wave for impedance measurement.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.impedance_measurement_mode",
        "documentation": {}
    },
    {
        "label": "LogLevel",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.log_level",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.log_level",
        "peekOfCode": "class LogLevel(Enum):\n    \"\"\"Enumeration of the available logging levels.\n    The logging level determines the verbosity of the log output. More critical\n    levels include messages from less critical ones.\n    Attributes\n    ----------\n    VERBOSE : int\n        The most verbose logging level, including all messages.\n    DEBUG : int\n        Includes debug messages and all more critical levels.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.log_level",
        "documentation": {}
    },
    {
        "label": "Polarity",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.polarity",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.polarity",
        "peekOfCode": "class Polarity(enum.Enum):\n    \"\"\"Enumeration of the possible polarities for bipolar electrodes.\n    For devices with bipolar electrodes, this enum allows for the selection of\n    which contact to use for a given measurement.\n    Attributes\n    ----------\n    NONE : int\n        No polarity is selected.\n    BOTH : int\n        Both positive and negative contacts are used.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.polarity",
        "documentation": {}
    },
    {
        "label": "BacoreConfig",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.sBacore_config_t",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.sBacore_config_t",
        "peekOfCode": "class BacoreConfig(ctypes.Structure):\n    \"\"\"\n    Python equivalent of the C struct `sBACORE_Config_t`.\n    This structure defines configuration options for the BrainAccess system,\n    including logging, data processing, and adapter selection.\n    It mirrors the C layout exactly, for use in `ctypes` bindings.\n    Attributes\n    ----------\n    log_buffer_size : ctypes.c_size_t\n        Size of the log buffer in bytes.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.sBacore_config_t",
        "documentation": {}
    },
    {
        "label": "StreamRate",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.stream_rate",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.stream_rate",
        "peekOfCode": "class StreamRate(Enum):\n    \"\"\"Enumeration of the available sample rates for the device's amplifiers.\n    Attributes\n    ----------\n    X16kHz : int\n        16000 samples per second.\n    X8kHz : int\n        8000 samples per second.\n    X4kHz : int\n        4000 samples per second.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.stream_rate",
        "documentation": {}
    },
    {
        "label": "Version",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "peekOfCode": "class Version(ctypes.Structure):\n    \"\"\"Represents a version number with major, minor, and patch components.\n    This class is used to represent software and hardware versions in a structured\n    way, following the principles of semantic versioning.\n    Attributes\n    ----------\n    major : int\n        The major version number, incremented for incompatible API changes.\n    minor : int\n        The minor version number, incremented for new, backward-compatible",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "documentation": {}
    },
    {
        "label": "is_version_compatible",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "peekOfCode": "def is_version_compatible(expected: Version, actual: Version) -> bool:\n    \"\"\"Checks if two versions are compatible.\n    Compatibility is determined based on the major version number. Two versions\n    are considered compatible if they share the same major version.\n    Parameters\n    ----------\n    expected : Version\n        The expected or required version.\n    actual : Version\n        The actual version to check.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "documentation": {}
    },
    {
        "label": "_dll.ba_is_version_compatible.argtypes",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "peekOfCode": "_dll.ba_is_version_compatible.argtypes = [\n    ctypes.POINTER(Version),\n    ctypes.POINTER(Version),\n]\n_dll.ba_is_version_compatible.restype = ctypes.c_bool\ndef is_version_compatible(expected: Version, actual: Version) -> bool:\n    \"\"\"Checks if two versions are compatible.\n    Compatibility is determined based on the major version number. Two versions\n    are considered compatible if they share the same major version.\n    Parameters",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "documentation": {}
    },
    {
        "label": "_dll.ba_is_version_compatible.restype",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "peekOfCode": "_dll.ba_is_version_compatible.restype = ctypes.c_bool\ndef is_version_compatible(expected: Version, actual: Version) -> bool:\n    \"\"\"Checks if two versions are compatible.\n    Compatibility is determined based on the major version number. Two versions\n    are considered compatible if they share the same major version.\n    Parameters\n    ----------\n    expected : Version\n        The expected or required version.\n    actual : Version",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.core.version",
        "documentation": {}
    },
    {
        "label": "EEG",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "peekOfCode": "class EEG:\n    \"\"\"EEG acquisition class.\n    Gathers data from brainaccess core and converts to MNE structure.\n    \"\"\"\n    def __init__(\n        self,\n        mode: str = \"accumulate\",\n    ) -> None:\n        \"\"\"Creates EEG object and initializes device with default parameters.\n        Parameters",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "documentation": {}
    },
    {
        "label": "EEGData_roll",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "peekOfCode": "class EEGData_roll:\n    \"\"\"Data structure to store rolling EEG data buffer\"\"\"\n    def __init__(self, info, lock, zeros_at_start: int = 1):\n        \"\"\"Initializes the EEGData_roll object.\n        Parameters\n        ----------\n        info : mne.Info\n            The MNE info object.\n        lock : threading.Lock\n            The threading lock.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "documentation": {}
    },
    {
        "label": "EEGData",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "peekOfCode": "class EEGData:\n    \"\"\"Object to store EEG data in accumulation mode\"\"\"\n    def __init__(self, info, lock, zeros_at_start: int = 2):\n        \"\"\"Initializes the EEGData object.\n        Parameters\n        ----------\n        info : mne.Info\n            The MNE info object.\n        lock : threading.Lock\n            The threading lock.",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.acquisition",
        "documentation": {}
    },
    {
        "label": "BrainAccessException",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "peekOfCode": "class BrainAccessException(Exception):\n    pass\ndef _callback() -> tuple:\n    success: bool = False\n    @ctypes.CFUNCTYPE(None, ctypes.c_bool, ctypes.c_void_p)\n    def callback(_success: bool, user_data: ctypes.c_void_p) -> None:\n        nonlocal success\n        success = bool(_success)\n    def get_success() -> bool:\n        return success",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "_Error",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "peekOfCode": "class _Error(enum.Enum):\n    OK = 0\n    CONNECTION = 1\n    UNSUPPORTED_DEVICE = 2\n    WRONG_VALUE = 3\n    BLUETOOTH_DISABLED = 4\n    BLUETOOTH_ADAPTER_NOT_FUND = 5\n    ADAPTER_OUT_OF_INDEX = 6\n    UPDATE_FILE_NOT_FOUND = 7\n    UPDATE_INITIATED_UNSUCCESSFULLY = 8",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "_ErrorBacore",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "peekOfCode": "class _ErrorBacore(enum.Enum):\n    OK = 0\n    CONFIG_TYPE = 1\n    WRONG_ADAPTER_VALUE = 2\n    INCOMPATIBLE_VERSION = 3\n    NOT_ENALBLED = 4\n    NOT_FOUND = 5\n    CONFIG_PARSE = 6\n    INIT_ALREADY_INITIALIZED = 7\n    INVALID_FILE_PATH = 8",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.utils.exceptions",
        "documentation": {}
    },
    {
        "label": "get_lib_name",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "peekOfCode": "def get_lib_name(name: str) -> str:\n    platform_name = platform.uname()[0]\n    if platform_name == \"Windows\":\n        return name + \".dll\"\n    elif platform_name == \"Linux\":\n        return \"lib\" + name + \".so\"\n    else:\n        raise BrainAccessException(f'Unsupported platform \"{platform_name}\"')\ndef load_library(name: str) -> ctypes.CDLL:\n    dll_name = get_lib_name(name)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "documentation": {}
    },
    {
        "label": "load_library",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "peekOfCode": "def load_library(name: str) -> ctypes.CDLL:\n    dll_name = get_lib_name(name)\n    try:\n        onlyfiles = [file.name for file in pathlib.Path(getcwd()).glob(\"*\")]\n        if dll_name in onlyfiles:\n            return ctypes.CDLL(join(getcwd(), dll_name))\n        onlyfiles = [file.name for file in _lib_directory.glob(\"*\")]\n        if dll_name in onlyfiles:\n            return ctypes.CDLL(join(_lib_directory, dll_name))\n        _lib = find_library(dll_name)",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "documentation": {}
    },
    {
        "label": "_lib_directory",
        "kind": 5,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "peekOfCode": "_lib_directory = pathlib.Path(__file__).parent / \"lib\"\ndef get_lib_name(name: str) -> str:\n    platform_name = platform.uname()[0]\n    if platform_name == \"Windows\":\n        return name + \".dll\"\n    elif platform_name == \"Linux\":\n        return \"lib\" + name + \".so\"\n    else:\n        raise BrainAccessException(f'Unsupported platform \"{platform_name}\"')\ndef load_library(name: str) -> ctypes.CDLL:",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.brainaccess.libload",
        "documentation": {}
    },
    {
        "label": "CustomBuildHook",
        "kind": 6,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "peekOfCode": "class CustomBuildHook(BuildHookInterface):\n    def initialize(self, version, build_data):\n        build_data['tag'] = f'py3-none-{get_platform_tag()}'",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "documentation": {}
    },
    {
        "label": "get_platform_tag",
        "kind": 2,
        "importPath": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "description": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "peekOfCode": "def get_platform_tag():\n    system = platform.system()\n    if system == \"Linux\":\n        return \"linux_x86_64\"\n    elif system == \"Darwin\":\n        return \"macosx_10_9_x86_64\"\n    elif system == \"Windows\":\n        return \"win_amd64\"\n    else:\n        raise RuntimeError(f\"Unsupported platform: {system}\")",
        "detail": "hotb_starter_code.BrainAccessSDK-windows.python_api.hatch_build",
        "documentation": {}
    },
    {
        "label": "eeg",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "description": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "peekOfCode": "eeg = acquisition.EEG()\n# define electrode locations\ncap: dict = {\n    0: \"Fp1\",\n    1: \"Fp2\",\n    2: \"O1\",\n    3: \"O2\",\n}\n# define device name\ndevice_name = \"BA HALO 089\"",
        "detail": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "documentation": {}
    },
    {
        "label": "device_name",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "description": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "peekOfCode": "device_name = \"BA HALO 089\"\n# start EEG acquisition setup\nwith EEGManager() as mgr:\n    eeg.setup(mgr, device_name=device_name, cap=cap, sfreq=250)\n    # Start acquiring data\n    eeg.start_acquisition()\n    print(\"Acquisition started\")\n    time.sleep(3)\n    start_time = time.time()\n    annotation = 1",
        "detail": "hotb_starter_code.examples.example_eeg_acquisition_to_mne",
        "documentation": {}
    },
    {
        "label": "sampling_rate",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "sampling_rate = 250\nt = np.arange(0, 5, step=1.0 / (sampling_rate))\nwave = 10 * np.sin(np.pi * 2 * 5 * t)\nwave += 100 * np.sin(np.pi * 2 * 23 * t)\nwave = wave.reshape(5, sampling_rate) + 2\nwave2 = 10 * np.sin(np.pi * 2 * 5 * t).reshape(5, sampling_rate) + 2\ndata = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "t = np.arange(0, 5, step=1.0 / (sampling_rate))\nwave = 10 * np.sin(np.pi * 2 * 5 * t)\nwave += 100 * np.sin(np.pi * 2 * 23 * t)\nwave = wave.reshape(5, sampling_rate) + 2\nwave2 = 10 * np.sin(np.pi * 2 * 5 * t).reshape(5, sampling_rate) + 2\ndata = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "wave",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "wave = 10 * np.sin(np.pi * 2 * 5 * t)\nwave += 100 * np.sin(np.pi * 2 * 23 * t)\nwave = wave.reshape(5, sampling_rate) + 2\nwave2 = 10 * np.sin(np.pi * 2 * 5 * t).reshape(5, sampling_rate) + 2\ndata = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "wave",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "wave = wave.reshape(5, sampling_rate) + 2\nwave2 = 10 * np.sin(np.pi * 2 * 5 * t).reshape(5, sampling_rate) + 2\ndata = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "wave2",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "wave2 = 10 * np.sin(np.pi * 2 * 5 * t).reshape(5, sampling_rate) + 2\ndata = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "data = np.stack([wave, wave2], axis=2)\ndata = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "data = np.moveaxis(data, 2, 0)\n# Calculate mean of the data\nmean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "mean = processor.mean(data[0, :, :])\n# Filter data\ndata_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "data_filtered",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "data_filtered = processor.filter_bandpass(data, sampling_rate, 48, 52)\n# Calculate fft\ndata_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "data_fft",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_eeg_processing",
        "description": "hotb_starter_code.examples.example_eeg_processing",
        "peekOfCode": "data_fft = processor.fft(data, sampling_rate)[\"mag\"]",
        "detail": "hotb_starter_code.examples.example_eeg_processing",
        "documentation": {}
    },
    {
        "label": "eeg",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_impedance_measurement",
        "description": "hotb_starter_code.examples.example_impedance_measurement",
        "peekOfCode": "eeg = acquisition.EEG()\ncap: dict = {\n  0: \"Fp1\",\n  1: \"Fp2\",\n  2: \"O1\",\n  3: \"O2\",\n}\n# define device name\ndevice_name = \"BA HALO 089\"\nwith EEGManager() as mgr:",
        "detail": "hotb_starter_code.examples.example_impedance_measurement",
        "documentation": {}
    },
    {
        "label": "device_name",
        "kind": 5,
        "importPath": "hotb_starter_code.examples.example_impedance_measurement",
        "description": "hotb_starter_code.examples.example_impedance_measurement",
        "peekOfCode": "device_name = \"BA HALO 089\"\nwith EEGManager() as mgr:\n    eeg.setup(mgr, device_name=device_name, cap=cap)\n    # Start measuring impedance\n    eeg.start_impedance_measurement()\n    time.sleep(2)\n    # Print impedances\n    start_time = time.time()\n    while time.time()-start_time < 20:\n        time.sleep(1)",
        "detail": "hotb_starter_code.examples.example_impedance_measurement",
        "documentation": {}
    },
    {
        "label": "butter_bandpass",
        "kind": 2,
        "importPath": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "description": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "peekOfCode": "def butter_bandpass(\n    lowcut: float, highcut: float, fs: int, order: int = 2\n) -> np.ndarray:\n    \"\"\"Design a bandpass Butterworth filter.\"\"\"\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    sos = butter(order, [low, high], analog=False, btype=\"bandpass\", output=\"sos\")\n    return sos\ndef butter_bandpass_filter(",
        "detail": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "documentation": {}
    },
    {
        "label": "butter_bandpass_filter",
        "kind": 2,
        "importPath": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "description": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "peekOfCode": "def butter_bandpass_filter(\n    data: np.ndarray, lowcut: float, highcut: float, fs: int, order: int = 2\n) -> np.ndarray:\n    \"\"\"Apply a bandpass Butterworth filter to the data.\"\"\"\n    sos = butter_bandpass(lowcut, highcut, fs, order=order)\n    y = sosfiltfilt(sos, data)\n    return y\ndef _acq_closure(ch_number: int = 1, buffer_length: int = 1000) -> tuple:\n    \"\"\"Acquisition callback closure.\"\"\"\n    data = np.zeros((ch_number, buffer_length))",
        "detail": "hotb_starter_code.examples.example_minimal_eeg_acquisition",
        "documentation": {}
    },
    {
        "label": "extract_bandpower",
        "kind": 2,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "def extract_bandpower(signal, fs, band):\n    freqs = np.fft.fftfreq(len(signal), 1/fs)\n    fft_vals = np.abs(np.fft.fft(signal))**2\n    band_power = fft_vals[(freqs >= band[0]) & (freqs <= band[1])].sum()\n    return band_power\nfs = 250  # czstotliwo prbkowania EEG (Hz)  zaley od opaski\nbands = {\"delta\":(0.5,4), \"theta\":(4,8), \"alpha\":(8,12), \"beta\":(12,30)}\n\"\"\"\nplt.figure(figsize=(10,5))\nplt.plot(ds_f[\"freq\"][:N//2], ds_f[\"O2\"][:N//2])",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "read_csv",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "read_csv = pd.read_csv('C:\\\\Users\\\\user\\\\GALERA\\\\hotb_starter_code\\\\csvfiles\\\\tiktok.csv')\nin_df = pd.DataFrame(read_csv)\ndf = in_df[[\"time\",\"O1\",\"O2\",\"Fp1\",\"Fp2\"]]\nsb.lineplot(df,x=\"time\",y=\"Fp2\")\nplt.show()\ndt = df[\"time\"].iloc[1] - df[\"time\"].iloc[0]\nN = len(df)\nfreqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "in_df",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "in_df = pd.DataFrame(read_csv)\ndf = in_df[[\"time\",\"O1\",\"O2\",\"Fp1\",\"Fp2\"]]\nsb.lineplot(df,x=\"time\",y=\"Fp2\")\nplt.show()\ndt = df[\"time\"].iloc[1] - df[\"time\"].iloc[0]\nN = len(df)\nfreqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "df = in_df[[\"time\",\"O1\",\"O2\",\"Fp1\",\"Fp2\"]]\nsb.lineplot(df,x=\"time\",y=\"Fp2\")\nplt.show()\ndt = df[\"time\"].iloc[1] - df[\"time\"].iloc[0]\nN = len(df)\nfreqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])\n    ds_f[col] = np.abs(fft_values)",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "dt = df[\"time\"].iloc[1] - df[\"time\"].iloc[0]\nN = len(df)\nfreqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])\n    ds_f[col] = np.abs(fft_values)\nds_f=ds_f.drop([0])\nprint(ds_f)\ndef extract_bandpower(signal, fs, band):",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "N = len(df)\nfreqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])\n    ds_f[col] = np.abs(fft_values)\nds_f=ds_f.drop([0])\nprint(ds_f)\ndef extract_bandpower(signal, fs, band):\n    freqs = np.fft.fftfreq(len(signal), 1/fs)",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "freqs",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "freqs = np.fft.fftfreq(N, d=dt)\nds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])\n    ds_f[col] = np.abs(fft_values)\nds_f=ds_f.drop([0])\nprint(ds_f)\ndef extract_bandpower(signal, fs, band):\n    freqs = np.fft.fftfreq(len(signal), 1/fs)\n    fft_vals = np.abs(np.fft.fft(signal))**2",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "ds_f",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "ds_f = pd.DataFrame({\"freq\": freqs})\nfor col in [\"O1\",\"O2\",\"Fp1\",\"Fp2\"]:\n    fft_values = np.fft.fft(df[col])\n    ds_f[col] = np.abs(fft_values)\nds_f=ds_f.drop([0])\nprint(ds_f)\ndef extract_bandpower(signal, fs, band):\n    freqs = np.fft.fftfreq(len(signal), 1/fs)\n    fft_vals = np.abs(np.fft.fft(signal))**2\n    band_power = fft_vals[(freqs >= band[0]) & (freqs <= band[1])].sum()",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "fs",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "fs = 250  # czstotliwo prbkowania EEG (Hz)  zaley od opaski\nbands = {\"delta\":(0.5,4), \"theta\":(4,8), \"alpha\":(8,12), \"beta\":(12,30)}\n\"\"\"\nplt.figure(figsize=(10,5))\nplt.plot(ds_f[\"freq\"][:N//2], ds_f[\"O2\"][:N//2])\nplt.title(\"Widmo sygnau O1\")\nplt.xlabel(\"Czstotliwo [Hz]\")\nplt.ylabel(\"Amplituda\")\nplt.show()\n\"\"\"",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "bands",
        "kind": 5,
        "importPath": "hotb_starter_code.data_in",
        "description": "hotb_starter_code.data_in",
        "peekOfCode": "bands = {\"delta\":(0.5,4), \"theta\":(4,8), \"alpha\":(8,12), \"beta\":(12,30)}\n\"\"\"\nplt.figure(figsize=(10,5))\nplt.plot(ds_f[\"freq\"][:N//2], ds_f[\"O2\"][:N//2])\nplt.title(\"Widmo sygnau O1\")\nplt.xlabel(\"Czstotliwo [Hz]\")\nplt.ylabel(\"Amplituda\")\nplt.show()\n\"\"\"",
        "detail": "hotb_starter_code.data_in",
        "documentation": {}
    },
    {
        "label": "name_lookup",
        "kind": 2,
        "importPath": "hotb_starter_code.device_name_lookup",
        "description": "hotb_starter_code.device_name_lookup",
        "peekOfCode": "def name_lookup() -> None:\n    core.init()\n    devices = core.scan()\n    if devices:\n        print(f\"Available devices: {[device.name for device in devices]}\")\n    else:\n        print(\"No devices were found!\")\n    core.close()\nif __name__ == \"__main__\":\n    name_lookup()",
        "detail": "hotb_starter_code.device_name_lookup",
        "documentation": {}
    },
    {
        "label": "calculate_band_power_mne",
        "kind": 2,
        "importPath": "hotb_starter_code.gemini",
        "description": "hotb_starter_code.gemini",
        "peekOfCode": "def calculate_band_power_mne(raw):\n    # 1. Wczytanie pliku\n    # 2. Obliczenie PSD (Power Spectral Density)\n    # fmax ustawiamy np. na 50 lub 100 Hz\n    spectrum = raw.compute_psd(method='welch', fmin=0.5, fmax=50)\n    # Pobieramy dane: (liczba_kanaw, liczba_czstotliwoci)\n    psds, freqs = spectrum.get_data(return_freqs=True)\n    # Lista kanaw (bez kanaw stymulacji/znacznikw, jeli s)\n    # W Twoim pliku main.py usuwae kolumn 4, tutaj MNE zazwyczaj sam oznacza typy kanaw\n    ch_names = raw.ch_names",
        "detail": "hotb_starter_code.gemini",
        "documentation": {}
    },
    {
        "label": "calculate_focus_index",
        "kind": 2,
        "importPath": "hotb_starter_code.gemini",
        "description": "hotb_starter_code.gemini",
        "peekOfCode": "def calculate_focus_index(df_bands):\n    \"\"\"\n    Oblicza indeks skupienia na podstawie gotowej ramki z mocami pasm.\n    Wzr: Beta / Theta na kanaach czoowych (Fp1, Fp2).\n    \"\"\"\n    # Filtrujemy tylko kanay czoowe, bo one najlepiej oddaj \"Executive Control\"\n    frontal_df = df_bands[df_bands[\"Channel\"].isin([\"Fp1\", \"Fp2\"])]\n    # Sumujemy moce z obu kanaw (urednianie przestrzenne)\n    avg_beta = frontal_df[\"Beta\"].mean()\n    avg_theta = frontal_df[\"Theta\"].mean()",
        "detail": "hotb_starter_code.gemini",
        "documentation": {}
    },
    {
        "label": "BANDS",
        "kind": 5,
        "importPath": "hotb_starter_code.gemini",
        "description": "hotb_starter_code.gemini",
        "peekOfCode": "BANDS = {\n    \"Delta\": (0.5, 4),\n    \"Theta\": (4, 8),\n    \"Alpha\": (8, 13),\n    \"Beta\": (13, 30),\n    \"Gamma\": (30, 45) # Czsto ogranicza si do 45/50 Hz ze wzgldu na szum sieci elektrycznej\n}\ndef calculate_band_power_mne(raw):\n    # 1. Wczytanie pliku\n    # 2. Obliczenie PSD (Power Spectral Density)",
        "detail": "hotb_starter_code.gemini",
        "documentation": {}
    },
    {
        "label": "df_bands",
        "kind": 5,
        "importPath": "hotb_starter_code.gemini",
        "description": "hotb_starter_code.gemini",
        "peekOfCode": "df_bands = calculate_band_power_mne(mne.io.read_raw_fif(\"dura.fif\", preload=True))\nprint(df_bands)\n# Wizualizacja\ndf_melted = df_bands.melt(id_vars=\"Channel\", var_name=\"Band\", value_name=\"Power\")\nsb.barplot(data=df_melted, x=\"Channel\", y=\"Power\", hue=\"Band\")\nplt.title(\"Moc pasm EEG na kana\")\nplt.show()",
        "detail": "hotb_starter_code.gemini",
        "documentation": {}
    },
    {
        "label": "df_melted",
        "kind": 5,
        "importPath": "hotb_starter_code.gemini",
        "description": "hotb_starter_code.gemini",
        "peekOfCode": "df_melted = df_bands.melt(id_vars=\"Channel\", var_name=\"Band\", value_name=\"Power\")\nsb.barplot(data=df_melted, x=\"Channel\", y=\"Power\", hue=\"Band\")\nplt.title(\"Moc pasm EEG na kana\")\nplt.show()",
        "detail": "hotb_starter_code.gemini",
        "documentation": {}
    },
    {
        "label": "fif_to_df",
        "kind": 2,
        "importPath": "hotb_starter_code.main",
        "description": "hotb_starter_code.main",
        "peekOfCode": "def fif_to_df(fif):\n    raw = mne.io.read_raw_fif(fif, preload=True)\n    data,times=raw.get_data(return_times=True)\n    t_df=pd.DataFrame(times)\n    df=pd.DataFrame(data)\n    df=df.transpose()\n    df.insert(0, 'time', t_df)\n    df=df.drop(4,axis=1)\n    df = df.set_axis([\"time\",\"O1\",\"O2\",\"Fp2\",\"Fp1\"], axis=1)\n    return df",
        "detail": "hotb_starter_code.main",
        "documentation": {}
    },
    {
        "label": "fourier_transform",
        "kind": 2,
        "importPath": "hotb_starter_code.main",
        "description": "hotb_starter_code.main",
        "peekOfCode": "def fourier_transform(df, signal_cols, time_col=\"time\"):\n    dt = df[time_col].iloc[1] - df[time_col].iloc[0]\n    N = len(df)\n    freqs = np.fft.fftfreq(N, d=dt)\n    ds_f = pd.DataFrame({\"freq\": freqs})\n    for col in signal_cols:\n        fft_values = np.fft.fft(df[col].values)\n        amplitudes = np.abs(fft_values)\n        mean_val = amplitudes.mean()\n        std_val = amplitudes.std()",
        "detail": "hotb_starter_code.main",
        "documentation": {}
    },
    {
        "label": "raw",
        "kind": 5,
        "importPath": "hotb_starter_code.readfif",
        "description": "hotb_starter_code.readfif",
        "peekOfCode": "raw = mne.io.read_raw_fif(\"VERYconcentratedtest.fif\", preload=True)\n#print(raw.info)\n# Wywietl kanay\n#print(raw.ch_names)\n# Obejrzyj dane w interaktywnym viewerze\n# Pobierz dane jako NumPy array\ndata, times = raw.get_data(return_times=True)\ndf=pd.DataFrame(data)\ndf=df.transpose()\n#df=df.drop(columns=[4])",
        "detail": "hotb_starter_code.readfif",
        "documentation": {}
    },
    {
        "label": "sk_lvl",
        "kind": 2,
        "importPath": "hotb_starter_code.test",
        "description": "hotb_starter_code.test",
        "peekOfCode": "def sk_lvl(sec_mne):\n    data, times = sec_mne.get_data(return_times=True)\n    df=pd.DataFrame(data)\n    df=df.transpose()\n    df=df.drop(columns=[4])\n    print(len(df))\n    return len(df)\n# start EEG acquisition setup\nwith EEGManager() as mgr:\n    eeg.setup(mgr, device_name=device_name, cap=halo, sfreq=250)",
        "detail": "hotb_starter_code.test",
        "documentation": {}
    },
    {
        "label": "eeg",
        "kind": 5,
        "importPath": "hotb_starter_code.test",
        "description": "hotb_starter_code.test",
        "peekOfCode": "eeg = acquisition.EEG()\n# define electrode locations depending on your device\nhalo: dict = {\n    0: \"Fp1\",\n    1: \"Fp2\",\n    2: \"O1\",\n    3: \"O2\",\n}\ncap: dict = {\n 0: \"F3\",",
        "detail": "hotb_starter_code.test",
        "documentation": {}
    },
    {
        "label": "device_name",
        "kind": 5,
        "importPath": "hotb_starter_code.test",
        "description": "hotb_starter_code.test",
        "peekOfCode": "device_name = \"BA HALO 089\"\ndef sk_lvl(sec_mne):\n    data, times = sec_mne.get_data(return_times=True)\n    df=pd.DataFrame(data)\n    df=df.transpose()\n    df=df.drop(columns=[4])\n    print(len(df))\n    return len(df)\n# start EEG acquisition setup\nwith EEGManager() as mgr:",
        "detail": "hotb_starter_code.test",
        "documentation": {}
    },
    {
        "label": "mne_raw",
        "kind": 5,
        "importPath": "hotb_starter_code.test",
        "description": "hotb_starter_code.test",
        "peekOfCode": "mne_raw = eeg.data.mne_raw\nprint(f\"MNE Raw object: {mne_raw}\")\n# Access data as NumPy arrays\ndata, times = mne_raw.get_data(return_times=True)\nprint(f\"Data shape: {data.shape}\")\n# save EEG data to MNE fif format\neeg.data.save(f'danilakoncentrat.fif')\n# Close brainaccess library\neeg.close()\n# conversion to microvolts",
        "detail": "hotb_starter_code.test",
        "documentation": {}
    },
    {
        "label": "sk_lvl",
        "kind": 2,
        "importPath": "hotb_starter_code.test_focus",
        "description": "hotb_starter_code.test_focus",
        "peekOfCode": "def sk_lvl(sec_mne):\n    data, times = sec_mne.get_data(return_times=True)\n    df=pd.DataFrame(data)\n    df=df.transpose()\n    df=df.drop(columns=[4])\n    print(len(df))\n    return len(df)\n# start EEG acquisition setup\nwith EEGManager() as mgr:\n    eeg.setup(mgr, device_name=device_name, cap=halo, sfreq=250)",
        "detail": "hotb_starter_code.test_focus",
        "documentation": {}
    },
    {
        "label": "eeg",
        "kind": 5,
        "importPath": "hotb_starter_code.test_focus",
        "description": "hotb_starter_code.test_focus",
        "peekOfCode": "eeg = acquisition.EEG()\n# define electrode locations depending on your device\nhalo: dict = {\n    0: \"Fp1\",\n    1: \"Fp2\",\n    2: \"O1\",\n    3: \"O2\",\n}\ncap: dict = {\n 0: \"F3\",",
        "detail": "hotb_starter_code.test_focus",
        "documentation": {}
    },
    {
        "label": "device_name",
        "kind": 5,
        "importPath": "hotb_starter_code.test_focus",
        "description": "hotb_starter_code.test_focus",
        "peekOfCode": "device_name = \"BA HALO 089\"\ndef sk_lvl(sec_mne):\n    data, times = sec_mne.get_data(return_times=True)\n    df=pd.DataFrame(data)\n    df=df.transpose()\n    df=df.drop(columns=[4])\n    print(len(df))\n    return len(df)\n# start EEG acquisition setup\nwith EEGManager() as mgr:",
        "detail": "hotb_starter_code.test_focus",
        "documentation": {}
    },
    {
        "label": "mne_raw",
        "kind": 5,
        "importPath": "hotb_starter_code.test_focus",
        "description": "hotb_starter_code.test_focus",
        "peekOfCode": "mne_raw = eeg.data.mne_raw\nprint(f\"MNE Raw object: {mne_raw}\")\n# Access data as NumPy arrays\ndata, times = mne_raw.get_data(return_times=True)\nprint(f\"Data shape: {data.shape}\")\n# save EEG data to MNE fif format\neeg.data.save(f'xd.fif')\n# Close brainaccess library\neeg.close()\n# conversion to microvolts",
        "detail": "hotb_starter_code.test_focus",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend",
        "description": "backend",
        "peekOfCode": "app = FastAPI()\nconnected_clients: list[WebSocket] = []\nlight_observers = []\n@app.get(\"/item/\")\nasync def read_item():\n    return JSONResponse(await db.get_accidents())\n@app.post(\"/event\")\nasync def event(location_id: int, accident_type: str):\n    'receives ongoing data from BCI and analyzes it'\n    timestamp = datetime.datetime.now().isoformat()",
        "detail": "backend",
        "documentation": {}
    },
    {
        "label": "light_observers",
        "kind": 5,
        "importPath": "backend",
        "description": "backend",
        "peekOfCode": "light_observers = []\n@app.get(\"/item/\")\nasync def read_item():\n    return JSONResponse(await db.get_accidents())\n@app.post(\"/event\")\nasync def event(location_id: int, accident_type: str):\n    'receives ongoing data from BCI and analyzes it'\n    timestamp = datetime.datetime.now().isoformat()",
        "detail": "backend",
        "documentation": {}
    },
    {
        "label": "Database",
        "kind": 6,
        "importPath": "db_requests",
        "description": "db_requests",
        "peekOfCode": "class Database:\n    def __init__(self):\n        self.__async_engine = create_async_engine(url=DATABASE,\n                                                  # echo=True,\n                                                  )\n        self.__async_session_factory = async_sessionmaker(self.__async_engine)\n        asyncio.run(self._init_models())\n    async def _init_models(self) -> None:\n        async with self.__async_engine.begin() as conn:\n            # await conn.run_sync(Base.metadata.drop_all)",
        "detail": "db_requests",
        "documentation": {}
    },
    {
        "label": "DATABASE",
        "kind": 5,
        "importPath": "db_requests",
        "description": "db_requests",
        "peekOfCode": "DATABASE = \"sqlite+aiosqlite:///database.db\"\nclass Database:\n    def __init__(self):\n        self.__async_engine = create_async_engine(url=DATABASE,\n                                                  # echo=True,\n                                                  )\n        self.__async_session_factory = async_sessionmaker(self.__async_engine)\n        asyncio.run(self._init_models())\n    async def _init_models(self) -> None:\n        async with self.__async_engine.begin() as conn:",
        "detail": "db_requests",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class Base:\n    pass\nclass SessionORM(Base):\n    __tablename__ = 'sessions'\n    'saves work sessions and neural activity'\n    id: Mapped[int] = mapped_column(primary_key=True,index=True)\n    duration: Mapped[int] = mapped_column() # duration in seconds\n    neural_data: Mapped[dict] = mapped_column(JSON)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    user: Mapped[\"UsersORM\"] = relationship(back_populates=\"sessions\")",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "SessionORM",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class SessionORM(Base):\n    __tablename__ = 'sessions'\n    'saves work sessions and neural activity'\n    id: Mapped[int] = mapped_column(primary_key=True,index=True)\n    duration: Mapped[int] = mapped_column() # duration in seconds\n    neural_data: Mapped[dict] = mapped_column(JSON)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    user: Mapped[\"UsersORM\"] = relationship(back_populates=\"sessions\")\nclass UsersORM(Base):\n    __tablename__ = 'users'",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "UsersORM",
        "kind": 6,
        "importPath": "models",
        "description": "models",
        "peekOfCode": "class UsersORM(Base):\n    __tablename__ = 'users'\n    'saves user data'\n    id: Mapped[int] = mapped_column(primary_key=True,index=True)\n    email: Mapped[str] = mapped_column(unique=True)\n    password: Mapped[str] = mapped_column()\n    sessions: Mapped[list[\"SessionORM\"]] = relationship(back_populates=\"user\", lazy=\"selectin\")",
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "raw",
        "kind": 5,
        "importPath": "sygnal_mne",
        "description": "sygnal_mne",
        "peekOfCode": "raw = mne.io.read_raw_fif(\"dura.fif\", preload=True)\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\nraw_filtered = raw_filtered.notch_filter(freqs=[50])\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\n#time.sleep(30)\nplt.show()",
        "detail": "sygnal_mne",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "sygnal_mne",
        "description": "sygnal_mne",
        "peekOfCode": "raw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\nraw_filtered = raw_filtered.notch_filter(freqs=[50])\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\n#time.sleep(30)\nplt.show()",
        "detail": "sygnal_mne",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "sygnal_mne",
        "description": "sygnal_mne",
        "peekOfCode": "raw_filtered = raw_filtered.notch_filter(freqs=[50])\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\n#time.sleep(30)\nplt.show()",
        "detail": "sygnal_mne",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "df = pd.read_csv(\"tiktok.csv\")\nsignal = df[\"value\"].values  # <-- wpisz waciw nazw kolumny\nsfreq = 250  # czstotliwo prbkowania (musisz zna!)\ninfo = mne.create_info(ch_names=[\"signal\"], sfreq=sfreq, ch_types=[\"eeg\"])\nraw = mne.io.RawArray(signal[np.newaxis, :], info)\n###  Usunicie szumu wysokoczstotliwociowego (low-pass)\nraw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "signal = df[\"value\"].values  # <-- wpisz waciw nazw kolumny\nsfreq = 250  # czstotliwo prbkowania (musisz zna!)\ninfo = mne.create_info(ch_names=[\"signal\"], sfreq=sfreq, ch_types=[\"eeg\"])\nraw = mne.io.RawArray(signal[np.newaxis, :], info)\n###  Usunicie szumu wysokoczstotliwociowego (low-pass)\nraw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "sfreq",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "sfreq = 250  # czstotliwo prbkowania (musisz zna!)\ninfo = mne.create_info(ch_names=[\"signal\"], sfreq=sfreq, ch_types=[\"eeg\"])\nraw = mne.io.RawArray(signal[np.newaxis, :], info)\n###  Usunicie szumu wysokoczstotliwociowego (low-pass)\nraw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "info",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "info = mne.create_info(ch_names=[\"signal\"], sfreq=sfreq, ch_types=[\"eeg\"])\nraw = mne.io.RawArray(signal[np.newaxis, :], info)\n###  Usunicie szumu wysokoczstotliwociowego (low-pass)\nraw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz\nraw_filtered = raw.copy().notch_filter(freqs=[50])",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw = mne.io.RawArray(signal[np.newaxis, :], info)\n###  Usunicie szumu wysokoczstotliwociowego (low-pass)\nraw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz\nraw_filtered = raw.copy().notch_filter(freqs=[50])\n###Wywietlenie sygnau przed i po filtracji",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw_filtered = raw.copy().filter(l_freq=None, h_freq=40)\n### Usunicie skadowej staej (DC offset)\nraw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz\nraw_filtered = raw.copy().notch_filter(freqs=[50])\n###Wywietlenie sygnau przed i po filtracji\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw_filtered = raw_filtered.filter(l_freq=1, h_freq=None)\n###  Bardzo popularny filtr pasmowy EEG\nraw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz\nraw_filtered = raw.copy().notch_filter(freqs=[50])\n###Wywietlenie sygnau przed i po filtracji\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\nraw_filtered = raw.copy().filter(1, 40).notch_filter(50)",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw_filtered = raw.copy().filter(l_freq=1, h_freq=40)\n#### Usunicie szumu sieciowego 50 Hz\nraw_filtered = raw.copy().notch_filter(freqs=[50])\n###Wywietlenie sygnau przed i po filtracji\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\nraw_filtered = raw.copy().filter(1, 40).notch_filter(50)",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw_filtered = raw.copy().notch_filter(freqs=[50])\n###Wywietlenie sygnau przed i po filtracji\nraw.plot(title=\"Przed filtracj\")\nraw_filtered.plot(title=\"Po filtracji\")\nraw_filtered = raw.copy().filter(1, 40).notch_filter(50)",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    },
    {
        "label": "raw_filtered",
        "kind": 5,
        "importPath": "tempCodeRunnerFile",
        "description": "tempCodeRunnerFile",
        "peekOfCode": "raw_filtered = raw.copy().filter(1, 40).notch_filter(50)",
        "detail": "tempCodeRunnerFile",
        "documentation": {}
    }
]